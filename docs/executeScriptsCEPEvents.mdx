---
sidebar_position: 5
---

import useBaseUrl from '@docusaurus/useBaseUrl';
import Anigif from '../src/components/Anigif'
import RetinaImg from '../src/components/RetinaImg'
import Youtube from '../src/components/YouTube'
import RoundButton from '../src/components/RoundButton'

# Execute Scripts with CEP Events

You can also remote-execute Automation Blocks scripts from other  extensions (CEP panels). If you develop your own extensions, there is no need to reinvent the wheel: Just use Automation Blocks inside your own extensions and speed up your development.

:::tip new in Automation Blocks 1.0.012

CEP events have been added in Autommation Blocks 1.0.012. If you use an older version, make sure to update!

:::

## Run Script File
*Event for Pr: `com.aescripts.AutomationBlocksPr.runScriptFile`<br/>
Event for Ae: `com.aescripts.AutomationBlocksAe.runScriptFile`*

To execute an Automation Blocks script, just send a CSEvent with type `com.aescripts.AutomationBlocksPr.runScriptFile` in Premiere Pro or `com.aescripts.AutomationBlocksAe.runScriptFile` in After Effects.
 
 In the event data, you need to provide a `filePath`, to specify the xml file containing the block script you want to execute:

```
// execute script test.xml without loading it into the UI
var event = new CSEvent('com.aescripts.AutomationBlocksPr.runScriptFile', 'APPLICATION');
event.data = {
    filePath: "/path/to/file/test.xml"
};
new CSInterface().dispatchEvent(event);
```
In order to make this work, Automation Blocks needs to be installed (and licensed) on the machine, but the Automation Blocks user interface does not need to be open.

If you run into any issues open http://localhost:2029/ with Chrome to see the debugger of the Automation Blocks API. Automation Blocks prints status messages in this console when it receives the event and also shows the errors there, if something went wrong.

### Callback

If you [register a callback](#callbacks), then Automation Blocks will send an event back to you after it executed the script (or if that failed). The data sent with the callback event will contain the following properties:
- **status** will be `ERROR` if loading or executing the script failed and `SUCCESS` otherwise.
- **result** will be an error message if status is `ERROR`. Otherwise it will contain the result of the script execution.


:::danger Input Blocks Limitation

Since this event executes the block scripts without a user interface, [input blocks](block-reference/userInterfaceAndComments.mdx#input_arg) will always use their default value. If you need user input, use the other user interface blocks, which create popup dialogs.

:::

##  Run Current Script

*Event for Pr: `com.aescripts.AutomationBlocksPr.runCurrentScript`<br/>
Event for Ae: `com.aescripts.AutomationBlocksAe.runCurrentScript`*

If the user interface of Automation Blocks is open , you can also ask it to run the block script, which is currently open in the UI:
```
// run the script that is currently open in the Automation Blocks UI
var event = new CSEvent('com.aescripts.AutomationBlocksPr.runCurrentScript', 'APPLICATION');
new CSInterface().dispatchEvent(event);
```

This event is handled by the panel showing the Automation Blocks UI. Hence, it only works if the Automation Blocks UI is open.
For debugging open the Automation Blocks panel at http://localhost:2026/ (note the 2026 instead of 2029!).

### Callback

If you [register a callback](#callbacks), the data sent with the callback event will contain the following properties:
- **status** will be `ERROR` if the script execution failed and `SUCCESS` otherwise.
- **result** will be an error message if status is `ERROR`. Otherwise it will contain the result of the script execution.


##  Load Script File
*Event for Pr: `com.aescripts.AutomationBlocksPr.loadScriptFile`<br/>
Event for Ae: `com.aescripts.AutomationBlocksAe.loadScriptFile`*

If the user interface of Automation Blocks is open, you can also tell it to open a block script of your choice in the user interface:

```
// load the block script test.xml into the Automation. Blocks UI
var event = new CSEvent('com.aescripts.AutomationBlocksPr.loadScriptFile', 'APPLICATION');
event.data = {
    filePath: "/path/to/file/test.xml"
};
new CSInterface().dispatchEvent(event);
```

This event is handled by the panel showing the Automation Blocks UI. Hence, it only works if the Automation Blocks UI is open.
For debugging open the Automation Blocks panel at http://localhost:2026/.

### Callback

If you [register a callback](#callbacks), the data sent with the callback event will contain the following properties:
- **status** will be `ERROR` if loading the script failed and `SUCCESS` otherwise.
- **result** will be an error message if status is `ERROR`. Otherwise it will be the empty string.


## Callbacks {#callbacks}

When you send an event to Automation Blocks, you can also request Automation Blocks to send an answer back to your CEP panel. 
For this, just add an object `callbackData` to the event data with the following properties:
- *eventType*: A string for the type of event you want to recieve. Make sure to choose a unique name, which does not overlap with events from other extensions.
- *customData*: Here you can pass any json object. Automation Blocks will send this data back with the reply. You can use this to pass unique IDs for each event, for example, such that you know to which your your events the reply belongs.

Here is an example:
```
// register an event handler to recieve the reply from Automation Blocks
new CSInterface().addEventListener(
  "my_reply_callback_unique_name",
  function (event) {
    var data = event.data;
    console.log("recieved reply event:", event.data);
  }
);

// now send your event
var myEvent = new CSEvent(
	"com.aescripts.AutomationBlocksPr.runScriptFile",
	"APPLICATION"
);
myEvent.data = {
	filePath: "path/to/test.xml",
	callbackData: {
	  eventType: "my_reply_callback_unique_name",
	  customData: {
		id: 1234,
		whatever: "foo",
	  },
	},
};
new CSInterface().dispatchEvent(myEvent);
```

## ExtendScript, Kbar & QuickMenu

You can also send the events from After Effects scripts (ExtendScript). This is in particular useful, since launcher tools like [Kbar](https://aescripts.com/kbar/) or [QuickMenu](https://aescripts.com/quick-menu/) can execute custom scripts. 


The syntax for ExtendScript is a little bit different, since you need to load the PlugPlugExternalObject library and also need to *JSON.stringify* your data. You can use the script code below to launch an Automation Blocks script from Kbar's "Run Scriptlet", for example. You can also save the code to a jsx file and run it from the Ae menu "File->Scripts->Run Script File" or from QuickMenu.

```
var xLib;
try {
    xLib = new ExternalObject("lib:\PlugPlugExternalObject");
} catch(e) { alert("Missing ExternalObject: "+e); }

if (xLib) {
	var eventObj = new CSXSEvent();
	eventObj.type = 'com.aescripts.AutomationBlocksAe.runScriptFile';
	eventObj.data = JSON.stringify({
		filePath: "/path/to/file/test.xml"
	});
	eventObj.dispatch();
}
```
Just replace `"/path/to/file/test.xml"` by the file path of the block script you want to execute.
